# Server Sync Protocol (Authoritative, WebSocket)

This document defines the **server-side sync behavior** for Insieme's authoritative event model. It focuses on WebSocket transport.

## Scope

- **JWT auth** (validation only). Token is issued externally.
- Server validates every event and decides to **commit** or **reject**.
- Server replies to the **origin client** and **broadcasts** committed events to all other connected clients whose subscriptions intersect the event's partitions.

## High-Level Responsibilities

1. **Connection management** (track clients + partition subscriptions).
2. **Validation + commit decision** for every submitted event.
3. **Sequential ordering** with global `committed_id`.
4. **Durable persistence** before responding "committed".
5. **Broadcast** committed events to other clients.
6. **Catch-up** for new connections (send missed committed events).

## Terms

- **id**: globally unique UUID from the client (draft id).
- **committed_id**: server-assigned global incremental id.
- **partitions**: array of logical streams the event belongs to.
- **sync envelope** (`payload` of a WebSocket message): the protocol-level wrapper around an event.
- **event payload** (`payload.event`): the application-level event data (type + payload).

## Message Envelope

All WebSocket messages (both directions) must include the following top-level fields:

- `type` (string): message type.
- `msg_id` (string): unique message id for tracing/debug. Generated by the sender, unique per connection. Not used for request/response correlation — use `payload.id` for event correlation and `payload.partitions` + `since_committed_id` for sync correlation.
- `timestamp` (number): sender time in ms. Client timestamps are informational only; the server uses its own clock for all authoritative timestamps (`status_updated_at`, `server_time`). Server should not reject based on client clock skew.
- `payload` (object): message-specific payload.
- `protocol_version` (string): current version is `"1.0"`.

Unknown fields should be ignored to allow forward compatibility.

Protocol requirements:
- Messages missing required envelope fields must be rejected with `bad_request`.
- If `protocol_version` is unsupported, respond with `error` including `supported_versions` and close the connection.
- Unknown message `type` should be rejected with `bad_request`.

## Connection State

- Messages other than `connect` and `heartbeat` sent before `connected` should be rejected with `bad_request`.
- The server must bind a connection to the authenticated identity from JWT.
- If the same `client_id` connects while an existing connection is active, the server should close the older connection. Only one connection per `client_id` is allowed.

## Handshake & Auth

### Client → Server: connect
```yaml
msg_id: msg-1
type: connect
timestamp: 1738451200000
protocol_version: "1.0"
payload:
  token: jwt
  client_id: client-123
  last_committed_id: 1200       # client's latest committed cursor
```

### Server → Client: connected
```yaml
msg_id: msg-2
type: connected
timestamp: 1738451200001
protocol_version: "1.0"
payload:
  client_id: client-123
  server_time: 1738451200000
  server_last_committed_id: 1700  # server's global high-watermark
  model_version: 3                # optional, present in model mode
```

Field semantics:
- `server_last_committed_id`: server's global high-watermark at handshake time. The client can use this to decide whether it needs to sync (if `server_last_committed_id > client's local cursor`, sync is needed).
- `model_version` (optional): current model/domain schema version. If the client's local snapshot has a different version, it must invalidate and re-sync.

### Auth Rules

- Server **validates JWT only** (signature + `exp`).
- Token is issued by an external auth service (not by this server).
- Required claim: `client_id` (must match `payload.client_id`).
- No partition scoping in JWT (access is global for now).
- On auth failure: send `error` with code `auth_failed` and close the connection.
- For all post-connect messages, the authenticated connection identity is authoritative. `payload.client_id` is untrusted input and may be omitted by clients. If present and mismatched, server must reject with `auth_failed`.
- For committed storage and outbound messages, server must write the authenticated `client_id`, not any caller-provided value.
- `connect` does not establish partition subscriptions; clients declare partitions in `sync` requests.
- If the JWT expires during a long-lived connection, the server should close the connection. Token refresh requires a new `connect`.

## Heartbeat & Timeouts

- Client must send `heartbeat` on a regular interval (implementation-defined).
- Server replies with `heartbeat_ack`.
- If no heartbeat is received within the server's timeout window, the server closes the connection.
- Reconnects must re-run `connect` and then `sync`.
- A client that is intentionally closing should send `disconnect` first so the server can release subscription state immediately.

## Message Types (WebSocket)

Message shapes below are normative. Unless a field is explicitly marked optional, it is required. Unknown fields may be ignored for forward compatibility.

### Client → Server

**submit_event**
```yaml
msg_id: msg-3
type: submit_event
timestamp: 1738451201000
protocol_version: "1.0"
payload:
  id: evt-uuid-1                    # globally unique event id
  client_id: client-123             # optional (server uses authenticated identity)
  partitions:
    - workspace-1
    - workspace-2
  event:                            # application-level event
    type: treePush
    payload:
      target: explorer
      value:
        id: A
      options:
        parent: _root
        position: first
```

**submit_events** (batch)
```yaml
msg_id: msg-batch-1
type: submit_events
timestamp: 1738451201000
protocol_version: "1.0"
payload:
  events:
    - id: evt-uuid-1
      partitions: [workspace-1]
      event:
        type: treePush
        payload:
          target: explorer
          value: { id: A }
          options: { parent: _root }
    - id: evt-uuid-2
      partitions: [workspace-1]
      event:
        type: treeUpdate
        payload:
          target: explorer
          value: { name: Updated }
          options: { id: A }
```

**sync**
```yaml
msg_id: msg-4
type: sync
timestamp: 1738451202000
protocol_version: "1.0"
payload:
  partitions:                       # partitions to fetch events for
    - workspace-1
  subscription_partitions:          # optional: full replacement set for broadcasts
    - workspace-1
    - workspace-2
  since_committed_id: 1200
  limit: 500
```

**disconnect**
```yaml
msg_id: msg-11
type: disconnect
timestamp: 1738451208000
protocol_version: "1.0"
payload:
  reason: client_shutdown
```

### Server → Client

**event_committed** (to origin client only — confirms the submitter's draft was accepted)
```yaml
msg_id: msg-5
type: event_committed
timestamp: 1738451205000
protocol_version: "1.0"
payload:
  id: evt-uuid-1
  client_id: client-123
  partitions:
    - workspace-1
    - workspace-2
  committed_id: 1201
  event:
    type: treePush
    payload:
      target: explorer
      value:
        id: A
      options:
        parent: _root
        position: first
  status_updated_at: 1738451205000
```

**event_rejected** (to origin client only)
```yaml
msg_id: msg-6
type: event_rejected
timestamp: 1738451205000
protocol_version: "1.0"
payload:
  id: evt-uuid-1
  client_id: client-123
  partitions:
    - workspace-1
  reason: validation_failed
  errors:                           # required when reason is validation_failed
    - field: event.payload.value.id  # path relative to submit_event payload
      message: duplicate id
  status_updated_at: 1738451205000
```

**event_broadcast** (to other subscribed clients — notifies peers of a new committed event)
```yaml
msg_id: msg-7
type: event_broadcast
timestamp: 1738451205000
protocol_version: "1.0"
payload:
  id: evt-uuid-1
  client_id: client-123
  partitions:
    - workspace-1
    - workspace-2
  committed_id: 1201
  event:
    type: treePush
    payload:
      target: explorer
      value:
        id: A
      options:
        parent: _root
        position: first
  status_updated_at: 1738451205000
```

`event_committed` and `event_broadcast` carry identical payload shapes. The distinction is the audience: `event_committed` goes to the origin client (to confirm its draft), `event_broadcast` goes to peers. Clients should use the message `type` to distinguish, not `payload.client_id`.

**submit_events_result** (response to batch submit)
```yaml
msg_id: msg-batch-2
type: submit_events_result
timestamp: 1738451202000
protocol_version: "1.0"
payload:
  results:
    - id: evt-uuid-1
      status: committed
      committed_id: 1201
      status_updated_at: 1738451201500
    - id: evt-uuid-2
      status: rejected
      reason: validation_failed
      errors:
        - field: event.payload.value.id
          message: duplicate id
      status_updated_at: 1738451201600
```

**sync_response**
```yaml
msg_id: msg-8
type: sync_response
timestamp: 1738451206000
protocol_version: "1.0"
payload:
  partitions:
    - workspace-1
  effective_subscriptions:          # current broadcast subscription set
    - workspace-1
    - workspace-2
  events:                           # committed events, same shape as event_broadcast.payload
    - id: evt-uuid-50
      client_id: client-456
      partitions: [workspace-1]
      committed_id: 1201
      event:
        type: treePush
        payload:
          target: explorer
          value: { id: B }
          options: { parent: _root }
      status_updated_at: 1738451200000
  next_since_committed_id: 1700     # cursor for next page (use as since_committed_id)
  sync_to_committed_id: 1700        # high-watermark, stable across pages in a sync cycle
  has_more: false
```

Cursor semantics:
- `next_since_committed_id`: the value the client should use as `since_committed_id` in the next `sync` request if `has_more=true`. After the final page (`has_more=false`), this is the client's new durable cursor.
- `sync_to_committed_id`: the server's high-watermark when the sync cycle started. Stable across all pages of the same cycle. Used by the client to decide how to handle broadcasts received during sync (see Broadcast Handling During Sync).

**heartbeat**
```yaml
msg_id: msg-9
type: heartbeat
timestamp: 1738451207000
protocol_version: "1.0"
payload: {}
```

**heartbeat_ack**
```yaml
msg_id: msg-10
type: heartbeat_ack
timestamp: 1738451207001
protocol_version: "1.0"
payload: {}
```

**error**
```yaml
msg_id: msg-err-1
type: error
timestamp: 1738451207002
protocol_version: "1.0"
payload:
  code: auth_failed
  message: Invalid token
  details: {}                       # optional, error-specific context
```

**version_changed** (model mode only)
```yaml
msg_id: msg-vc-1
type: version_changed
timestamp: 1738451210000
protocol_version: "1.0"
payload:
  old_model_version: 3
  new_model_version: 4
```

On receiving `version_changed`, clients must invalidate snapshots for affected partitions and perform a full catch-up (`since_committed_id=0`).

## Server Flow

### 1) Submit Event

1. Receive `submit_event` (or `submit_events` for batch).
2. Validate payload (tree or model mode).
3. If invalid → send `event_rejected` to origin client. No broadcast occurs on rejection.
4. If valid → assign `committed_id` (global, monotonic).
5. Persist the committed event (durable write).
6. Send `event_committed` to origin client.
7. Broadcast `event_broadcast` to all other clients whose subscriptions intersect the event's partitions.

Batch processing (`submit_events`) semantics:
- Server must process `payload.events` in list order.
- Each item is validated against state resulting from prior committed items in the same batch.
- Max batch size: 100 events (server configurable).
- Each committed item still generates individual `event_broadcast` messages for subscribed peers.

### 2) Sync / Catch-Up

When a client connects (or reconnects), it sends `sync` with its last known `committed_id`. The server returns all committed events **after** that id whose partitions intersect the requested partitions.

- If there are many events, respond in **pages** with `limit` + `has_more`.
- Clients loop until `has_more=false`.
- The server must include `sync_to_committed_id` (high-watermark when the cycle started) and keep it constant across all pages.
- Clients must not send concurrent `sync` requests on the same connection. Wait for each `sync_response` before sending the next `sync`.

#### Sync Acknowledgment

`sync_response` is intentionally unacknowledged. Client must durably persist applied events and `next_since_committed_id` before considering the page complete. If the client crashes before persisting, it re-requests from its last durable cursor. Server idempotency guarantees correctness.

#### Broadcast Handling During Sync

While a sync cycle is active (between the first `sync` request and the final `sync_response` with `has_more=false`):

- Apply `sync_response.events` immediately (idempotent by `id`/`committed_id`).
- If an `event_broadcast` arrives with `committed_id <= sync_to_committed_id`, apply idempotently (ignore if already present from sync).
- If an `event_broadcast` arrives with `committed_id > sync_to_committed_id`, buffer it until the cycle completes.
- After the final page, flush buffered broadcasts in `committed_id` order.
- If the buffer is lost (crash/restart), re-sync from the last durable cursor.

#### Future Cursor Validation

If `since_committed_id` is higher than the server's current max committed_id, the server should return an empty `sync_response` with `has_more=false` and `sync_to_committed_id` set to the server's actual max. The client can detect the mismatch and trigger a full re-sync if needed.

## Validation

- The server is authoritative: it **must** validate every event.
- For **model mode**, validate the event envelope and schema (same rules as the client).
- For **tree mode**, validate the action payloads. The server must implement the same tree operation semantics as the client library (see Tree Operation Edge Cases in client-drafts.md).

### Valid Event Types

Top-level `event.type` values:
- Tree mode: `set`, `unset`, `init`, `treePush`, `treeDelete`, `treeUpdate`, `treeMove`
- Model mode: `event` (with envelope: `schema`, `data`, optional `meta`)

Mode constraints:
- Tree mode must reject `event` type.
- Model mode must reject non-`event` types except `init` if explicitly enabled.

### Model Versioning

- Server must expose `model_version` in `connected` and `sync_response` (when in model mode).
- If the model version changes while clients are connected, server must send `version_changed`.
- On receiving `version_changed`, clients must invalidate snapshots and full re-sync.

## Partition Semantics

- `partitions` must be a **non-empty array** of strings.
- Max length: 64 partitions per event.
- Each partition name must be non-empty and <= 128 bytes UTF-8.
- Duplicates are normalized away before storage.
- The server treats `partitions` as a **set**: deduplicate and sort before storage. Use the normalized array for hashing/equality checks.
- If limits are exceeded, reject with `validation_failed`.

Submission vs subscription:
- Subscription set controls which broadcasts a connection receives.
- It does **not** restrict which partitions a client may submit events for.

## Partition Subscriptions

Sync catch-up scope and broadcast subscription scope are distinct:

- `sync.payload.partitions`: which partitions to return events for in this sync request.
- `sync.payload.subscription_partitions` (optional): full replacement set for future broadcasts.

Rules:
1. If `subscription_partitions` is present, server must atomically replace the connection's subscription set with exactly that set.
2. If `subscription_partitions` is absent, server must keep existing subscriptions unchanged.
3. Server must return `effective_subscriptions` in `sync_response.payload`.
4. Clients should send `subscription_partitions` on first sync after connect.

Partition removal: to leave partition P, send `subscription_partitions` that excludes P. Server must apply the replacement atomically. All subscriptions are removed on connection close.

If a client adds a new partition, it must sync from `since_committed_id=0` for that partition's history.

## Error Codes (Canonical)

| Code | Connection | Meaning |
|------|-----------|---------|
| `auth_failed` | close | Invalid JWT, expired token, or client_id mismatch. |
| `bad_request` | keep open | Malformed message, missing fields, or unknown message type. |
| `validation_failed` | keep open | Schema or model validation failure on submitted event. |
| `rate_limited` | keep open | Client exceeded allowed rate. Payload may include `retry_after_ms`. |
| `server_error` | close | Unexpected internal error. Client should reconnect and retry pending drafts. |
| `protocol_version_unsupported` | close | Unsupported protocol version. Payload includes `supported_versions: ["1.0"]`. |

For `server_error`: the client cannot know whether the operation was persisted. On reconnect, retry pending drafts — the server's idempotency-by-`id` guarantees correctness.

## Ordering & Idempotency

- `committed_id` is **monotonic globally**, never reused, survives server restarts.
- `since_committed_id` in sync is **exclusive** (return events with committed_id > since).
- The server must dedupe by `id` (global UUID). If the same `id` is submitted again, return the existing committed result instead of re-committing.
- If the same `id` is submitted with a **different payload**, reject with `validation_failed` and a descriptive error message.
- Broadcasts include both `id` and `committed_id` to support client idempotency.

Payload equality:
- The server must compare payloads by a **stable canonical form** (sorted JSON or hash over normalized `partitions` + `event`). `client_id` is not part of the comparison — the `id` uniquely identifies the event regardless of which connection submits it.

## Broadcast to Origin

- The server must send `event_committed` to the origin client.
- Additionally broadcasting `event_broadcast` to the origin client is **optional**; if it happens, the client must be idempotent by `id` / `committed_id`.

## Limits & Backpressure

- Server should enforce a max message size (implementation-defined).
- Server should cap in-flight drafts per client (implementation-defined).
- `sync.payload.limit` must be clamped to [50, 1000]. If client sends a value outside this range, server should coerce to the nearest bound.
- On overload, server returns `rate_limited` and may close the connection.

## Storage Expectations

Server storage is **committed-only**:

- Append-only log of committed events.
- Index by `committed_id`.
- Store `partitions` as an array; optionally maintain an `event_partitions(id, partition)` index for fast membership queries.
- Optional snapshots (committed-only) to speed up sync.

## Retention / Compaction

- Because events can belong to multiple partitions, an event should only be pruned when **all** referenced partitions have advanced past its `committed_id` (or equivalent retention policy).

## Durability Guarantees

- `event_committed` / `event_broadcast` must only be sent **after** the committed event is durably persisted.
- On server restart, the commit log is the source of truth for replay and sync. In-memory subscription state is rebuilt from active connections (clients must reconnect and re-sync).
- If the server crashes between durable persist and broadcast, the origin client never receives confirmation. On reconnect, the client retries pending drafts; the server dedupes by `id` and returns the existing committed result. Peers receive the event on their next sync.
